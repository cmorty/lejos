<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en"><head>
<!-- CSS -->
<link rel="stylesheet" href="../r_css/lejos-tutorial.css" type="text/css" />
<!-- ICON -->
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /><title>Behavior programming</title>

<meta name="GENERATOR" content="OpenOffice.org 2.4 (Win32)" />
<meta name="AUTHOR" content="Roger" />
<meta name="CREATED" content="20080820;14050000" />
<meta name="CHANGED" content="20080820;14274389" />
<style type="text/css">
<!--
@page { size: 8.5in 11in; margin-right: 1.25in; margin-top: 1in; margin-bottom: 1in }
P { margin-bottom: 0.08in; direction: ltr; color: #000000; widows: 2; orphans: 2 }
P.western { font-family: "Times New Roman", serif; font-size: 12pt; so-language: en-US }
P.cjk { font-family: "Times New Roman", serif; font-size: 12pt }
P.ctl { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ar-SA }
H1 { margin-bottom: 0.04in; direction: ltr; color: #ff6600; widows: 2; orphans: 2 }
H1.western { font-family: "Arial", sans-serif; font-size: 16pt; so-language: en-US }
H1.cjk { font-family: "Times New Roman", serif; font-size: 16pt }
H1.ctl { font-family: "Arial", sans-serif; font-size: 16pt; so-language: ar-SA }
H2 { margin-bottom: 0.08in; direction: ltr; color: #ff950e; widows: 2; orphans: 2 }
H2.western { font-family: "Arial", sans-serif; font-size: 14pt; so-language: en-GB; font-style: italic }
H2.cjk { font-family: "Times New Roman", serif; font-size: 14pt; font-style: italic }
H2.ctl { font-family: "Arial", sans-serif; font-size: 14pt; so-language: ar-SA; font-style: italic }
H3 { margin-left: 0.2in; margin-bottom: 0.08in; direction: ltr; color: #000000; widows: 2; orphans: 2 }
H3.western { font-family: "Arial", sans-serif; font-size: 13pt; so-language: en-GB; font-style: normal }
H3.cjk { font-family: "Times New Roman", serif; font-size: 13pt; font-style: normal }
H3.ctl { font-family: "Arial", sans-serif; font-size: 13pt; so-language: ar-SA; font-style: normal }
P.body-text-2-western { margin-left: 0.1in; font-family: "Times New Roman", serif; font-size: 12pt; so-language: en-US }
P.body-text-2-cjk { margin-left: 0.1in; font-family: "Times New Roman", serif; font-size: 12pt }
P.body-text-2-ctl { margin-left: 0.1in; font-family: "Times New Roman", serif; font-size: 12pt; so-language: ar-SA }
P.body-text-3-western { margin-left: 0.2in; font-family: "Times New Roman", serif; font-size: 12pt; so-language: en-US }
P.body-text-3-cjk { margin-left: 0.2in; font-family: "Times New Roman", serif; font-size: 12pt }
P.body-text-3-ctl { margin-left: 0.2in; font-family: "Times New Roman", serif; font-size: 8pt; so-language: ar-SA }
A:link { color: #0000ff }
A:visited { color: #800080 }
-->
</style>
</head>
<body>
<a id="top" name="top"></a><!-- N1: HEADER -->
<table class="n1t1" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td><img src="../r_media/images/tutorial_header1.jpg" /></td>
<td align="right"><img src="../r_media/images/tutorial_header2.jpg" /></td>
</tr>
</tbody>
</table>
<!-- N2: CONTENTS -> NAVIGATION SYSTEMS AND CONTENTS -->
<table class="n2t1" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="n2t1r1c1">
<p><a href="#1.Behavior%20programming%7Coutline">Behavior
programming</a></p>
<p style="margin-left: 0.17in;"><a href="#1.1.Programming%20Behavior%20with%20leJOS%20NXJ%7Coutline">Programming
Behavior with leJOS NXJ</a></p>
<p style="margin-left: 0.17in;"><a href="#1.2.The%20Behavior%20API%7Coutline">The Behavior API</a></p>
<p style="margin-left: 0.33in;"><a href="#1.2.1.lejos.subsumption.Behavior%7Coutline">lejos.subsumption.Behavior</a></p>
<p style="margin-left: 0.33in;"><a href="#1.2.2.lejos.subsumption.Arbitrator%7Coutline">lejos.subsumption.Arbitrator</a></p>
<p style="margin-left: 0.17in;"><a href="#1.3.Advanced%20Behavior%20Coding%7Coutline">Advanced
Behavior Coding</a></p>
<p style="margin-left: 0.33in;"><a href="#1.3.1.Coding%20bomb%20proof%20takeControl%28%29%20Methods%7Coutline">Coding
bomb proof takeControl() Methods</a></p>
<p style="margin-left: 0.33in;"><a href="#1.3.2.Coding%20Solid%20action%28%29%20and%20suppress%28%29%20Methods%7Coutline">Coding
Solid action() and suppress() Methods</a></p>
<p style="margin-left: 0.33in;"><a href="#1.3.3.Summary%7Coutline">Summary</a></p>
</td>
<td><!-- DO NOT MANINPULATE -->
<div id="BreadCrumbs"> <a href="../index.htm" target="_top">Home Page</a> &gt; <a href="#">Behavior
programming</a> </div>
<div class="NavBit"> <a target="_top" href="../AdvancedTopics/UnderstandingFilesLCPMemTools.htm">«&nbsp;Previous</a>&nbsp;&#8226;&nbsp;<a href="../index.htm">TOC</a>&nbsp;&#8226;&nbsp;<a href="../index.htm">Next&nbsp;»</a> </div>
<h1 class="western"><a name="1.Behavior programming|outline"></a>Behavior
programming</h1>
<p class="western"><br />
<br />
</p>
<h2 class="western" lang="en-GB"><a name="1.1.Programming Behavior with leJOS NXJ|outline"></a>
Programming Behavior with leJOS NXJ</h2>
<p class="western"><br />
<br />
</p>
<p class="body-text-2-western">When most people
start programming a robot, they think of the program flow as a series
of if-thens, which is remeniscent of structured programming (Figure 1).
This type of programming is very easy to get started in and hardly
requires any thought or design beforehand. A programmer can just sit at
the computer and start typing. The problem is, the code ends up as
spaghetti code; all tangled up and difficult to expand. The behavior
control model, in contrast, requires a little more planning before
coding begins, but the payoff is that each behavior is nicely
encapsulated within an easy to understand structure. This will
theoretically make your code easier to understand by other programmers
familiar with the behavior control model, but more importantly it
becomes very easy to add or remove specific behaviors from the overall
structure, without negative repercussions to the rest of the code.
Let's examine how to do this in leJOS NXJ.</p>
<p class="body-text-2-western" style="margin-left: 0in;"><font color="#000000"><img src="Behavior%20programming_html_m3f7048b9.jpg" name="graphics1" align="left" border="1" height="229" hspace="12" width="408" /><br clear="left" />
</font><br />
<br />
</p>
<p class="western"> Figure 1: Structured programming
visualized.</p><br /><h3 class="western" lang="en-GB"><a name="1.2.The Behavior API|outline"></a> The Behavior
API</h3>
<p class="body-text-2-western">The Behavior API is
very simple, and is composed of only one interface and one class. The
Behavior interface is used to define behaviors. The Behavior interface
is very general, so it works quite well because the individual
implementations of a behavior vary widely. Once all the Behaviors are
defined, they are given to an Arbitrator to regulate which behaviors
should be activated. All classes and interfaces for Behavior control
are located the lejos.subsumption package. The API for the Behavior
interface is as follows.</p>
<h3 class="western" lang="en-GB"><a name="1.2.1.lejos.subsumption.Behavior|outline"></a>
lejos.subsumption.Behavior</h3><ul>
<li>
<p class="western">boolean takeControl() </p>
</li>
</ul>
<p class="body-text-2-western">Returns a boolean
value to indicate if this behavior should become active. For example,
if a touch sensor indicates the robot has bumped into an object, this
method should return true.</p>
<ul>
<li>
<p class="western">void action() </p>
</li>
</ul>
<p class="body-text-2-western">The code in this
method initiates an action when the behavior becomes active. For
example, if takeControl() detects the robot has collided with an
object, the action() code could make the robot back up and turn away
from the object.</p>
<ul>
<li>
<p class="western">void suppress() </p>
</li>
</ul>
<p class="body-text-2-western">The code in the
suppress() method should immediately terminate the code running in the
action() method. The suppress() method can also be used to update any
data before this behavior completes.</p>
<p class="body-text-2-western">As you can see, the
three methods in the Behavior interface are quite simple. If a robot
has three discreet behaviors, then the programmer will need to create
three classes, with each class implementing the Behavior interface.
Once these classes are complete, the code should hand the Behavior
objects off to the Arbitrator to deal with.</p>
<h3 class="western" lang="en-GB"><a name="1.2.2.lejos.subsumption.Arbitrator|outline"></a>
lejos.subsumption.Arbitrator</h3>
<p class="body-text-3-western" lang="en-GB">The
constructors are::</p>
<ul>
<li>
<p class="western">public Arbitrator(Behavior []
behaviors,boolean returnWhenInactive) <br />
C<font size="3"><span lang="en-US">reates an
Arbitrator object that regulates when each of the behaviors will become
active. The higher the index array number for a Beha</span></font>vior,
the higher the priority level.<br />
Parameters:
<br /></p><div style="margin-left: 40px;">an array of Behaviors&nbsp;<br /><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">boolean indicator ; &nbsp;if true, the start()
method will return if no behavior is active and no behavior should take
control.. </span></div></li></ul><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;"></span><ul><li><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">public Arbitrator(Behavior [] behaviors) &nbsp;</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;"> <br />same as&nbsp; Arbitrator(Behavior [] behaviors, <b>true </b>);&nbsp;</span></li></ul>&nbsp;<p class="body-text-3-western">Public Methods </p>
<ul>
<li>
<p class="western">public void start() <br />
Starts the arbitration system.</p>
</li>
</ul>
<p class="body-text-3-western">The
Arbitrator class is even easier to understand than Behavior. When an
Arbitrator object is instantiated, it is given an array of Behavior
objects. Once it has these, the start() method is called and it begins
arbitrating. &nbsp;It finds the highest priority behavior that should
become active by&nbsp; calling&nbsp; the takeControl() method on each
Behavior object,
starting with the object with the highest index number in the array. It
works its way down through the array untill the a Behavior returns <span style="font-weight: bold;">true</span> to takeControl(). Then it &nbsp;executes the suppress() method on the
current
active behavior (if there is one), which forces its action() method to
exit. &nbsp;The Aribtrator calls <br />the&nbsp;
action() method
of
&nbsp;the highest priority behavior. &nbsp;But it will not make the
action() call consecutively to the same beahvior. &nbsp;So no behavior
can&nbsp; run twice in a row.&nbsp; &nbsp; If two
behaviors both want to take control, then only the higher level
behavior will be allowed (Figure 2).</p>
<p class="western"><font color="#000000"><img src="Behavior%20programming_html_m1576a1ab.jpg" name="graphics2" align="left" border="1" height="182" hspace="12" width="373" /><br clear="left" />
</font><br />
<br />
</p>
<p class="western"> Figure 2: Higher level behaviors
suppress lower level behaviors.</p><p class="western"></p>

<p class="body-text-3-western">Now that we are
familiar with the Behavior API under leJOS, let's look at a simple
example using three behaviors. For this example, we will program some
behavior for a simple robot with differential steering. This robot will
drive forward as it's primary low-level behavior. When it hits an
object, a high priority behavior will become active to back the robot
up and turn it 90 degrees. There will also be a third behavior which we
will insert into the program after the first two have been completed.
Let's start with the first behavior.</p>
<p class="body-text-3-western">As we saw in the
Behavior interface, we must implement the methods action(), suppress(),
and takeControl(). The behavior for driving forward will take place in
the action() method. It simply needs to make motors A and C rotate
forward, but will not exit until suppress() is called. &nbsp; Without
the while() loop, the action method would exit immediately, and there
would be no active behavior (even though the motors are still running).</p>
<p class="western"><span id="Frame1" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.38in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public void action()
{<br />
&nbsp;&nbsp;&nbsp;Motor.A.forward();<br />
&nbsp;&nbsp;&nbsp;Motor.C.forward();&nbsp;
&nbsp;&nbsp;&nbsp;<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">That was easy enough! The suppress()
method is even easier. &nbsp;Since the action() method exits
immediately, the&nbsp; the suppress() method &nbsp;does not need to do
anything!;:</p>
<p class="western"><span id="Frame2" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.8in; height: 0.8in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public void
suppress() {<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">Now
we need to implement a method to tell Arbitrator when this Behavior
should become active. As we outlined earlier, this robot&nbsp;should&nbsp; drive
forward always, unless some other Behavior becomes active. &nbsp; So this Behavior
should always want to take control (it's a bit of a control freak). The
takeControl() method should return true, no matter what is happening.
This may seem counter intuitive, but rest assured that higher level
behaviors will be able to cut in on this behavior when the need arises.
The method appears as follows:</p>
<p class="western"><span id="Frame3" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.59in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public boolean
takeControl() {<br />
&nbsp;&nbsp;&nbsp;return true;<br />
}</font></font></p>
</span><br clear="left" />
</p>
<p class="body-text-3-western">That's all it takes
to define our first Behavior to drive the robot forward. The complete
code listing for this class is as follows:</p>
<p class="western"><span id="Frame4" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 4.79in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">import
lejos.subsumption.*;<br />
import lejos.nxt.*;<br />
<br />
public class DriveForward implements Behavior {<br />
<br />
&nbsp;&nbsp;&nbsp;public boolean takeControl() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void suppress() {<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void action() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.forward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.forward();<br />
&nbsp;&nbsp;&nbsp;}<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">The second behavior
is a little more complicated than the first, but still very similar.
The main action of this behavior is to reverse and turn when the robot
strikes an object. In this example, we would like the behavior to take
control only when the touch sensor strikes an object, so the
takeControl() method will be defined as follows:</p>
<p class="western"><span id="Frame5" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.75in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public boolean
takeControl() {<br />
&nbsp;&nbsp;&nbsp;return Sensor.S2.readBooleanValue();<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="western">For the action, we want the robot
to back up and rotate when it strikes an object, so we will define the
action() method as follows:</p>
<p class="western"><span id="Frame6" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 4.3in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public void action()
{<br />
&nbsp;&nbsp;&nbsp;// Back up:<br />
&nbsp;&nbsp;&nbsp;Motor.A.backward();<br />
&nbsp;&nbsp;&nbsp;Motor.C.backward();<br />
&nbsp;&nbsp;&nbsp;try{Thread.sleep(1000);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;// Rotate by causing one wheel to stop:<br />
&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;try{Thread.sleep(300);}catch(Exception e)
{}<br />
&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
}</font></font></p>
</span><br clear="left" />
<br />
Defining the
suppress() method for this behavior is quite easy in this example. The
action() method above is the sort of method that runs very quickly (1.3
seconds) and is usually high priority. We can either stop it dead by
stopping motor movement, or we could wait for it to complete the
backing up maneuver. To keep things simple, lets just stop the motors
from rotating:<br />
</p>
<div id="Frame7" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.8in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public void
suppress() {<br />
&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
}</font></font></p>
</div>
<br clear="left" />
<br />While this suppress() method does not cause &nbsp;action() to
exit immediately, &nbsp;is does stop the motors. &nbsp;So the robot
does not move till the action() method exits, &nbsp;within 1.3 seconds
at most.

<p class="body-text-3-western">The complete listing
for this behavior is as follows:</p>
<p class="western"><span id="Frame8" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 4.57in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">import
lejos.subsumption.*;<br />
<br />
import lejos.nxt.*;<br />
<br />
public class HitWall implements Behavior {<br />
&nbsp;&nbsp;&nbsp;public boolean takeControl() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
Sensor.S2.readBooleanValue();<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void suppress() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void action() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Back up:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.backward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.backward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{Thread.sleep(1000);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Rotate
by causing only one wheel to stop:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{Thread.sleep(300);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
&nbsp;&nbsp;&nbsp;}<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>

<p class="body-text-3-western">We now have our two
behaviors defined, and it's a simple matter to make a class with a
main() method to get things started. All we need to do is create an
array of our Behavior objects, and instantiate and start the Arbitrator
as shown in the following code listing:</p>
<p class="western"><span id="Frame9" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 4.14in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">import
lejos.subsumption.*;<br />
<br />
public class BumperCar {<br />
&nbsp;&nbsp;&nbsp;public static void main(String [] args) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior b1
= new DriveForward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior b2
= new HitWall();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior []
bArray = {b1, b2};<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arbitrator
arby = new Arbitrator(bArray);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arby.start();<br />
&nbsp;&nbsp;&nbsp;}<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">The above code is
fairly easy to understand. The first two lines in the main() method
create instances of our Behaviors. The third line places them into an
array, with the lowest priority behavior taking the lowest array index.
The fourth line creates the Arbitrator, and the fifth line starts the
Arbitration process. When this program is started the robot will scurry
forwards until it bangs into an object, then it will retreat, rotate,
and continue with its forward movement until the power is shut off.</p>
<p class="body-text-3-western">This seems like a lot
of extra work for two simple behaviors, but now let's see how easy it
is to insert a third behavior without altering any code in the other
classes. This is the part that makes behavior control systems very
appealing for robotics programming. Our third behavior could be just
about anything. We'll have this new behavior monitor the battery level
and play a tune when it dips below a certain level. Examine the
completed Behavior:</p>
<p class="western"><span id="Frame10" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 5.96in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">import
lejos.subsumption.*;<br />
import lejos.nxt.*;<br />
<br />
public class BatteryLow implements Behavior {<br />
&nbsp;&nbsp;&nbsp;private float LOW_LEVEL;<br />
<br />
&nbsp;&nbsp;&nbsp;private static final short [] note = {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2349,115,
0,5, 1760,165, 0,35, 1760,28, 0,13, 1976,23,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,18,
1760,18, 0,23, 1568,15, 0,25, 1480,103, 0,18,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1175,180,
0,20, 1760,18, 0,23, 1976,20, 0,20, 1760,15,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,25,
1568,15, 0,25, 2217,98, 0,23, 1760,88, 0,33, 1760,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;75, 0,5,
1760,20, 0,20, 1760,20, 0,20, 1976,18, 0,23,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1760,18,
0,23, 2217,225, 0,15, 2217,218};<br />
<br />
&nbsp;&nbsp;&nbsp;public BatteryLow(float volts) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOW_LEVEL =
volts;<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public boolean takeControl() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float
voltLevel = (ROM.getBatteryPower() * 10 / 355);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
displayNum = (int)(voltLevel * 100);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCD.setNumber(0x301f,
displayNum, 0x3004);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LCD.refresh();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
voltLevel &lt; LOW_LEVEL;<br />
&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;public void suppress() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Nothing
to suppress<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void action() {<br />&nbsp; &nbsp; &nbsp; Motor.A.stop();<br />&nbsp; &nbsp; &nbsp; Motor.C.stop()<br />&nbsp; &nbsp; &nbsp; play();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{Thread.sleep(3000);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.exit(0);<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public static void play() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int
i=0;i&lt;note.length; i+=2) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final
short w = note[i+1];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sound.playTone(note[i],
w);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(w*10);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
catch (InterruptedException e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;}<br />
}</font></font></p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">The complete tune is
stored in the note array at line 6 and the method to play the notes is
at line 30. This behavior will take control only if the current battery
level is less the voltage specified in the constructor. The
takeControl() method looks a little inflated, and that's because it
also displays the battery charge to the LCD display. The action() and
suppress() methods are comparatively easy. Action makes a bunch of
noise, then exits the program as soon as it is called. Since this
behavior stops the program, there is no need to create a suppress()
method. </p>
<p class="body-text-3-western">To insert this
Behavior into our scheme is a trivial task. We simply alter the code of
our main class as follows:</p>
<p class="western"><span id="Frame11" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 4.17in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public class
BumperCar {<br />
&nbsp;&nbsp;&nbsp;public static void main(String [] args) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior b1
= new DriveForward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior b2
= new BatteryLow(6.5f);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior b3
= new HitWall();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Behavior []
bArray = {b1, b2, b3};<br />
&nbsp;&nbsp;&nbsp;Arbitrator arby = new Arbitrator(bArray);<br />
&nbsp;&nbsp;&nbsp;arby.start();<br />
&nbsp;&nbsp;&nbsp;}<br />
} </font></font> </p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">Note: The voltage
level of the NXT at rest is different from the voltage when in action.
The voltage level at rest might be 7.8 V, but when motors are activated
they naturally cause a drop in the voltage reading. Make sure the
voltage threshold used in the BatteryLow constructor is low enough.</p>
<p class="body-text-3-western">This example
beautifully demonstrates the real benefit of behavior control coding.
Inserting a new behavior, no matter what the rest of the code looks
like, is simple. The reason for this is grounded in object oriented
design; each behavior is a self contained, independent object.</p>
<p class="body-text-3-western">TIP: When creating a
behavior control system, it is best to program each behavior one at a
time and test them individually. If you code all the behaviors and then
upload them all at once to the NXT brick, there is a good chance a bug
will exist somewhere in the behaviors, making it difficult to locate.
By programming and testing them one at a time it makes it easier to
identify where the problem was introduced.</p>
<p class="body-text-3-western">Behavior coding is
predominantly used for autonomous robots - robots that work
independently, on their own free will. A robot arm controlled by a
human would likely not use behavior programming, although it would be
possible. For example, a robot arm with four joystick movements could
have a behavior for each direction of movement. But as you may recall,
behaviors are ordered with the highest order taking precedence over
lower order behaviors. Who is to say that pushing left on the joystick
would take precedence over pushing up? In other words, behavior control
in anything other than autonomous robots is largely overkill.</p>
<p class="western"><font color="#0000ff"><u><a href="#_top">Back to Topt</a></u></font></p>
<h2 class="western" lang="en-GB"><a name="1.3.Advanced Behavior Coding|outline"></a>
Advanced Behavior Coding</h2>
<p class="body-text-2-western">It would be nice if
all behaviors were as simple as the examples given above, but in more
complex coding there are some unexpected results that can sometimes be
introduced. Threads, for example, can sometimes be difficult to halt
from the suppress() method, which can lead to two different threads
fighting over the same resources - often the same motor! Another
problem that can potentially occur in multi-threaded programs is that
events go undetected, such as touch sensor hits. These are a few of the
pitfalls we will be examining in this section. Let's start by looking
at what is generally the least complicated of the three Behavior
methods to implement; the takeControl() method.</p>
<p class="body-text-2-western">Note: The behavior
control API used by leJOS NXJ is a modified version of the model
proposed by Rodney Brooks. His model is all done at the lowest level
possible - the motors. This prevents higher level classes from being
used in behaviors. For example, the Navigator class accesses the motors
of the NXT directly, so with the original behavior control model
Navigator could not be used. Also, if both motors are moving forward,
and a higher level behavior takes command it is not clear if all lower
level motor movements should be stopped. What if the higher level
behavior only uses one of the motors? Should the other keep moving
forward? And will this lead to odd behavior? These are the problems the
leJOS Behavior Control API tries to address. </p>
<h3 class="western" lang="en-GB"><a name="1.3.1.Coding bomb proof takeControl() Methods|outline"></a>
Coding bomb proof takeControl() Methods</h3>
<p class="body-text-2-western">It is important for
takeControl() methods to be responsive in behavior control systems.
When a bumper collides with an object, the robot must stop or reverse
direction immediately; otherwise it will continue to move forward into
the object. Sometimes when an event occurs, such as a touch sensor
press, the program misses the event because the NXT is executing
another thread. By the time it gets to the takeControl() method the
sensor has been released and the program misses its opportunity to
activate the proper behavior action. In this section we will learn how
to make fool-proof takeControl() methods.</p>
<p class="western"><span id="Frame12" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 3.68in; height: 1.44in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">public boolean
takeControl() {<br />
&nbsp;&nbsp;&nbsp;boolean pass = false;<br />
&nbsp;&nbsp;&nbsp;if(direction == EAST)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Sensor.S1.readValue()
&gt; 60)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(Sensor.S2.readValue()
&lt; 20)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass
= true;<br />
&nbsp;&nbsp;&nbsp;return pass;<br />
}</font></font></p>
</span><br clear="left" />
In the above example we used single indicators of whether or not to
take control. For example, it took one reading from the Sensor class to
check if the touch sensor was hit. The takeControl() method can also
make a decision to take control based on a number of different values.
It could initiate an action if it is facing east, the light reading is
greater than 60, and the temperature is less than 20 degrees:Likewise,
a different behavior could just as easily check on the same data, only
react differently based on different values. For example, another
Behavior could initiate a different action if the robot is facing west,
the light reading is less than 60, and temperature is greater than 20
degrees. So a robot can initiate an unlimited number of responses with
only a few sensors at its disposal. This leads to another point about
implementing the takeControl() method. </p>
<p class="body-text-2-western">With the Arbitrator
cycling through all the takeControl() methods, there could be a
significant delay in checking a condition, such as whether a touch
sensor has been tapped. It's a feature of the imperfect world we live
in that, when the robot strikes an object, the touch sensor may not
remain pressed. It sometimes bounces off the object into a position
where the bumper is no longer pressing on the touch sensor. You may
have noticed in the example that it relies on checking touch very
often. What if the touch sensor is momentarily activated, but the
Arbitrator misses this fact? The solution is to use a SensorListener,
and have it set a flag to indicate the event has occurred. Let's take
the HitWall Behavior from the example above and modify it so it uses a
SensorListener:</p>
<p class="western"><span id="Frame13" style="border: 1px solid rgb(0, 0, 0); padding: 0.05in 0.1in; background: rgb(255, 255, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; float: left; width: 6.22in;" dir="ltr">
<p style="margin-top: 0.02in;"><font face="Courier New, monospace"><font style="font-size: 9pt;" size="2">import
lejos.subsumption.*;<br />
import lejos.nxt.*;<br />
<br />
public class HitWall implements Behavior, SensorListener {<br />
&nbsp;&nbsp;&nbsp;boolean hasCollided;<br />
<br />
&nbsp;&nbsp;&nbsp;// Constructor:<br />
&nbsp;&nbsp;&nbsp;public HitWall() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasCollided
= false;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SensorPort.S2.addSensorListener(this);<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void stateChanged(Sensor bumper,
int oldValue, int newValue) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(bumper.readBooleanValue()
== true)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasCollided
= true;<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public boolean takeControl() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hasCollided)
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasCollided
= false; // reset value<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
true;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
false;<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void suppress() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
&nbsp;&nbsp;&nbsp;}<br />
<br />
&nbsp;&nbsp;&nbsp;public void action() {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Back up:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.backward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.backward();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{Thread.sleep(1000);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Rotate
by causing only one wheel to stop:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.A.stop();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{Thread.sleep(300);}catch(Exception
e) {}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Motor.C.stop();<br />
&nbsp;&nbsp;&nbsp;}<br />
} </font></font> </p>
</span><br clear="left" />
<br />
<br />
</p>
<p class="body-text-3-western">T<font size="3"><span lang="en-US">he above code implements a SensorPortListener,
and hence implements the stateChanged() method. It is important to add
the sensor listener to Sensor.S2, as shown in line 10. Notice the
stateChanged() method does not simply return the value of the bumper
Sensor; rather, if the Sensor value is true then it changes the
hasCollided variable to true. If, on the next pass, the sensor value is
false then hasCollided will remain true until takeControl() has seen
the hasCollided value. Once takeControl() sees there has been a
collision, then hasCollided is reset back to false (line 20). With this
new code, it should </span></font>be impossible for the
robot to miss any collisions with the bumper!</p>
<h3 class="western" lang="en-GB"><a name="1.3.2.Coding Solid action() and suppress() Methods|outline"></a>
Coding Solid action() and suppress() Methods</h3>
<p class="body-text-3-western">In order to code
functional action() and suppress() pairs, it is necessary to understand
how arbitration works. Arbitrator has a separate auxillary thread
that&nbsp; continually&nbsp; cycles through
each of its Behaviors, checking each takeControl() method to see if
the&nbsp; Behavior should be activated. It starts with the
highest priority Behavior and goes down array to find the highest
priority behavior that should take control. &nbsp;If this is higher
than the proirity level of the current active behavior, the current
behavior is suppressed. &nbsp;When the current action() methods exits,
the
main thrad of the Arbitrator&nbsp; runs &nbsp; the action() method for
the highest
priority&nbsp; Behavior. &nbsp;This thread blocks while the action()
method runs, which is why suppress() is called in the auxilliary
thriead. &nbsp; If the takeControl() from the
previous Behavior continues to say true, it does not run action()
again This is important -&nbsp; a single Behavior can not be executed
twice
in a row.&nbsp;&nbsp;</p>
<p class="body-text-3-western">Note: If you would
like to remove any mystery about what goes on in the Arbitrator class,
take a look at the source code located in
src/classes/lejos/subsumption/Arbitrator.java.</p>
<p class="body-text-3-western">To program individual
behaviors it is important to understand the fundamental differences
between types of behaviors. Behavior actions come in three basic
varieties:</p>

<ol><li>Discrete actions which finish
quickly (e.g. back up and turn) &nbsp;</li><li>Actions that start running
and keep going an indefinite period until they are suppressed
(e.g.&nbsp; following a wall). </li><li>Action
methods that return immediately, but leave side effects such as motors
running or &nbsp;other threads that are still executing. </li></ol>
<ul>


</ul><p class="body-text-3-western">The DriveForward Behavior above is an example of type 3, which is potentially dangerous. &nbsp;When action()
returns,
&nbsp;the&nbsp; Arbitrator treats the behavior as inactive and
will <span style="font-weight: bold;">not</span>
call its suppress() method.&nbsp; It is then the responsibility of any
new behavior to deal with the side effects left by the previous one.
&nbsp;If the only side effect is motors running, &nbsp;this may
not be
a problem. &nbsp;But it is dangerous for&nbsp;
action()&nbsp; to exit
and leave&nbsp; a complex task running in a separate thread.
&nbsp;&nbsp;&nbsp;The example works because the other behaviors call
motor methods, and&nbsp; motor methods work currectly no matter the
motor was doing at the time the method was called. &nbsp;In general, it
is safer to use &nbsp;a type 2 &nbsp;Behavior that leaves no side
effects when &nbsp;suppress(0 is called and action() exits. <br />&nbsp;Here is&nbsp; simple way to code a DriveForward behavior that meets this requirement :</p><table style="text-align: left; width: 490px; height: 346px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td><small><span style="font-family: Courier New;">public class DriveForward_1 implements Behavior {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public boolean takeControl() {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; }</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">/**</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;* does the clean up of side effects</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;*/</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public void suppress()</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.A.stop();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.C.stop();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; }</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">/**</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;* This method exits only when suppress is called()</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;*/</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public void action() {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.A.forward();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.C.forward();<br /></span></small><div style="margin-left: 40px;"><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">while(Motor.A.isMoving() ||&nbsp;</span><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">Motor.B.isMoving()) &nbsp; <br />{<br />&nbsp; &nbsp;Thread.yield();<br />}</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;"> </span><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;"> </span></div><small><span style="font-family: Courier New;">&nbsp;&nbsp; }</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">}</span></small></td></tr></tbody></table><p class="body-text-3-western">The suppress() method causes the action() method to quit because it stops the motors. </p><p class="body-text-3-western">A more general design pattern for a type 2 behavior is illustrated in this version of the DriveForward behavior: &nbsp;</p><table style="text-align: left; width: 365px; height: 386px;" border="1" cellpadding="2" cellspacing="2"><tbody><tr><td><small><span style="font-family: Courier New;">public class DriveForward_2 implements Behavior {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">private boolean keepGoing = true;;</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public boolean takeControl() {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; }</span><br style="font-family: Courier New;" /><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public void suppress()</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp; keepGoing = false;</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; }</span><br style="font-family: Courier New;" /><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; public void action() </span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; {</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("DRIVE");</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.A.forward();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.C.forward();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keepGoing = true;</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(keepGoing)<br /></span></small><div style="margin-left: 40px;"><small><span style="font-family: Courier New;">{</span></small><br /><div style="margin-left: 40px;"><small><span style="font-family: Courier New;">Thread.yield();</span></small><br /></div><small><span style="font-family: Courier New;">}</span></small><br style="font-family: Courier New;" /><small><span style="font-family: Courier New;"></span></small></div><small><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.A.stop();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Motor.B.stop();</span><br style="font-family: Courier New;" /><span style="font-family: Courier New;">&nbsp;&nbsp; }</span></small></td></tr></tbody></table>
<p class="body-text-3-western">In this design pattern, the <span style="font-weight: bold;">while</span>
loop &nbsp;could be a very complex repeated task. &nbsp;Note that the
suppress() &nbsp;code makes no assumptions about the details of the
action() method, only that it will exit promptly when &nbsp;<span style="font-style: italic;">keepGoing</span> is set&nbsp; <span style="font-weight: bold;">false</span>.&nbsp;</p><p class="body-text-3-western">A final bit of advice: write your code&nbsp; to minimize interactions between Behaviors. &nbsp;To do this: &nbsp; &nbsp;</p>
<ol>
<li>&nbsp;make
no assumptions about the state of the robot&nbsp; when&nbsp; action()&nbsp; is called (for example, first stop all motors)&nbsp;</li>
<li>&nbsp;leave the robot in a safe state when the &nbsp;action()&nbsp;
method exits.&nbsp;</li><li>&nbsp;cause the&nbsp; action() method to exit quickly when suppress() is called. </li>
</ol>
<h3 class="western" lang="en-GB"><a name="1.3.3.Summary|outline"></a> Summary</h3>
<p class="western">So why use the Behavior API? The
best reason is because in programming we strive to create the simplest,
most powerful solution possible, even if it takes slightly more time.
The importance of reusable, maintainable code has been demonstrated
repeatedly in the workplace, especially on projects involving more than
one person. If you leave your code and come back to it several months
later, the things that looked so obvious suddenly don't anymore. With
Behavior control, you can add and remove behaviors without even looking
at the rest of the code, even if there are 10 or more bahaviors in the
program.&nbsp; Another big plus of behavior control is programmers
can exchange Behaviors with each other easily, which fosters code
reusability. Hundreds of interesting, generic behaviors could be
uploaded to websites, and you could simply pick the behaviors you want
to add to your robot (assuming your robot is the correct type of
robot). This reusability of code can be taken forward even more by
using standard leJOS NXJ classes such as the Navigation API. <br />
<br />
</p>
<p class="western"><font color="#0000ff"><u><a href="#_top">Back to Top</a></u></font></p>
<!-- DO NOT TOUCH --> <br />
<div class="NavBit"> <a target="_top" href="../AdvancedTopics/UnderstandingFilesLCPMemTools.htm">«&nbsp;Previous</a>&nbsp;&#8226;&nbsp;<a href="../index.htm">TOC</a>&nbsp;&#8226;&nbsp;<a href="../index.htm">Next&nbsp;»</a> </div>
<br />
</td>
<td> </td>
</tr>
</tbody>
</table>
</body></html>